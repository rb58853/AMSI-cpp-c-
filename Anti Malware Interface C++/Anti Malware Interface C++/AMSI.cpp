#include <iostream>
#include <amsi.h>
//#pragma comment(lib, "amsi.lib")

#define AMSIPROJECTNAME "MyAmsiScanner"

using namespace std;

struct ScanResult {
	HRESULT RiskLevel;
	BOOL IsMalware;
};

struct Sample {
	BYTE* data;
	ULONG size;
};

HRESULT Scan(LPCTSTR fname, BYTE* sample, ULONG sampleSize, struct ScanResult* scanResult) {
	HRESULT hResult = S_OK;
	HAMSICONTEXT amsiContext;
	AMSI_RESULT amsiRes = AMSI_RESULT_DETECTED;
	HAMSISESSION session = nullptr;

	ZeroMemory(&amsiContext, sizeof(amsiContext));

	hResult = AmsiInitialize((LPCWSTR)AMSIPROJECTNAME, &amsiContext);
	if (hResult != S_OK) {
		OutputDebugString((LPCWSTR)"AmsiInitialize failed");
		return hResult;
	}

	hResult = AmsiOpenSession(amsiContext, &session);
	if (hResult != S_OK || session == nullptr) {
		OutputDebugString((LPCWSTR)"AmsiOpenSession failed");
		return hResult;
	}

	// If one of the above is turned off, you will get this error:
	// "Failed to scan with error code 0x80070015. Reason: The device is not ready."

	hResult = AmsiScanBuffer(amsiContext, sample, sampleSize, (LPCWSTR)fname, session, &amsiRes);
	if (hResult != S_OK) {
		OutputDebugString((LPCWSTR)"AmsiScannerBuffer failed");
		cerr << "AmsiScanBuffer failed. Did you disable something for Windows Defender?" << endl;;
		return hResult;
	}

	// Any return result equal to or larger than 32768 is considered malware, and the content should be blocked.

	scanResult->RiskLevel = amsiRes;
	scanResult->IsMalware = AmsiResultIsMalware(amsiRes);

	AmsiUninitialize(amsiContext);
	CoUninitialize();

	return S_OK;
}

void static GetSampleFile(LPCSTR fname, struct Sample* sample);

BOOL HasMalware(char const* file_url)
{
	Sample sample;
	GetSampleFile(file_url, &sample);
	ScanResult scanResult;
	Scan((LPCTSTR)"fname", sample.data, sample.size, &scanResult);
	return scanResult.IsMalware;
}

void static GetSampleFile(LPCSTR fname, struct Sample* sample) {
	HANDLE hFile = CreateFileA(fname, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		throw std::runtime_error("Invalid file handle");
	}

	DWORD dwFileSize = GetFileSize(hFile, NULL);
	if (dwFileSize == INVALID_FILE_SIZE || dwFileSize == 0) {
		throw std::runtime_error("Failed to get the file size");
	}

	BYTE* buffer = (BYTE*)VirtualAlloc(NULL, dwFileSize, MEM_COMMIT, PAGE_READWRITE);
	if (!buffer) {
		throw std::runtime_error("Failed to allocate memory for file");
	}

	DWORD dwBytesRead;
	if (!ReadFile(hFile, buffer, dwFileSize, &dwBytesRead, NULL)) {
		throw std::runtime_error("Failed to read file");
	}

	CloseHandle(hFile);

	sample->data = (BYTE*)buffer;
	sample->size = dwFileSize;
}