namespace MalwareScan.AMSI
{
    using System;
    using System.IO;

    using static AmsiWrapper;

    public class MalwareScanner
    {
        private readonly string appName = "MalwareScanner.AMSI";

        private readonly Lazy<IntPtr> amsiContextLazy;
        public MalwareScanner() { }
        public MalwareScanner(string applicationName)
        {
            if (!String.IsNullOrWhiteSpace(applicationName))
            {
                this.appName = applicationName;
            }

            this.amsiContextLazy = new Lazy<IntPtr>(
                () =>
                    {
                        IntPtr ctx;
                        int result;
                        try
                        {
                            // logger.Debug("Starting to initialise AMSI");
                            result = AmsiInitialize(this.appName, out ctx);
                        }
                        catch (Exception e)
                        {
                            // logger.Error(e, "Failed to initialise AMSI - aborting");
                            throw new AMSIException($"Failed to initialise AMSI (the first thing we do): {e.Message}. See the inner exception for more details.", e);
                        }

                        if (result != 0)
                        {
                            // logger.Error("AMSI Intialisation returned an unexpected result: {result}. Aborting.", result);
                            throw new AMSIException($"Failed to open an AMSI Session - the Initialise call returned 0x{result:X}");
                        }

                        return ctx;
                    });
        }

        public bool HasVirus(string str, string filename)
        {
            int result;
            int scanResult;
            try
            {
                var context = this.amsiContextLazy.Value;
                var session = this.OpenSession();
                result = AmsiScanString(context, str, filename, session, out scanResult);
            }
            catch (Exception e)
            {
                throw new Exception($"The attempt to scan a test string failed with an exception: {e.Message}");
            }
            return HasMalware(scanResult);
        }
        public bool HasVirus(Stream stream, string filename)
        {
            return this.HasVirus(Tools.CopyToByteArray(stream), filename);
        }
        public bool HasVirus(byte[] bytearray, string filename)
        {
            if (bytearray == null)
            {
                throw new ArgumentException("An null array is not valid", nameof(bytearray));
            }

            if (string.IsNullOrWhiteSpace(filename))
            {
                throw new ArgumentException("An empty filename is not allowed", nameof(filename));
            }

            if (bytearray.Length == 0)
            {
                // logger.Warn("You have passed in empty stream or array with the name {filename}. This usually indicates a problem with stream handling in your code. However, as it may be valid, the scanner will return a 'no virus found' result", filename);
                return false;
            }

            IntPtr session = IntPtr.Zero;

            try
            {
                session = this.OpenSession();
                var scanResult = this.Scan(bytearray, filename, session);
                // logger.Debug("Scan result for {filename}: {result}", filename, scanResult);
                var hasMalware = HasMalware(scanResult);

                if (hasMalware)
                {
                    // logger.Warn("{filename} was found to contain malware", filename);
                }
                else
                {
                    // logger.Debug("{filename} was not found to contain malware", filename);
                }

                return hasMalware;
            }
            finally
            {
                if (session != IntPtr.Zero)
                {
                    AmsiCloseSession(this.amsiContextLazy.Value, session);
                }
            }
        }
        private static bool HasMalware(int scanResult)
        {
            // See https://msdn.microsoft.com/en-us/library/windows/desktop/dn889584(v=vs.85).aspx
            // ReSharper disable InconsistentNaming
            // ReSharper disable UnusedVariable
            const int // AMSI_RESULT_CLEAN = 0,
                      // AMSI_RESULT_NOT_DETECTED = 1,
                      AMSI_RESULT_BLOCKED_BY_ADMIN_START = 16384,
                      AMSI_RESULT_BLOCKED_BY_ADMIN_END = 20479,
                      AMSI_RESULT_DETECTED = 32768;

            // ReSharper enable InconsistentNaming
            // ReSharper enable UnusedVariable
            if (scanResult >= AMSI_RESULT_DETECTED)
            {
                return true;
            }

            if (scanResult >= AMSI_RESULT_BLOCKED_BY_ADMIN_START && scanResult <= AMSI_RESULT_BLOCKED_BY_ADMIN_END)
            {
                // logger.Error("The AMSI scan result {result} indicates a problem with permissions on the machine. See https://msdn.microsoft.com/en-us/library/windows/desktop/dn889584(v=vs.85).aspx", scanResult);
                throw new AMSIException($"The admin policy on this machine does not allow you to scan. The value returned was {scanResult}. See https://msdn.microsoft.com/en-us/library/windows/desktop/dn889584(v=vs.85).aspx");
            }

            return false;
        }
        private int Scan(byte[] bytearray, string filename, IntPtr session)
        {
            // logger.Debug($"Starting {nameof(this.Scan)} for {{filename}}", filename);
            int result;
            var length = Convert.ToUInt32(bytearray.Length);
            int scanResult;
            try
            {
                result = AmsiScanBuffer(this.amsiContextLazy.Value, bytearray, length, filename, session, out scanResult);
            }
            catch (Exception e)
            {
                // logger.Error(e, "An unexpected error occured calling AmsiScanBuffer for {filename}", filename);
                throw new AMSIException(
                    $"An unexpected error occured calling AmsiScanBuffer: {e.Message}. See the inner exception for more details.",
                    e);
            }

            if (result != 0)
            {
                // logger.Error("An unexpected result (HRESULT): {result} was returned when calling AmsiScanBuffer for {filename}. Aborting.", result, filename);
                throw new AMSIException($"Failed to scan {filename}. The call to AmsiScanBuffer returned 0x{result:X}.");
            }

            // logger.Debug($"{nameof(this.Scan)} is returning {{result}} for {{filename}}", scanResult, filename);
            return scanResult;
        }
        private IntPtr OpenSession()
        {
            // logger.Debug($"Starting {nameof(this.OpenSession)}");
            IntPtr session;
            int result;
            try
            {
                result = AmsiOpenSession(this.amsiContextLazy.Value, out session);
            }
            catch (Exception e)
            {
                // logger.Error(e, "Failed to open an AMSI Session. Aborting.");
                throw new AMSIException($"Failed to open an AMSI Session: {e.Message}. See the inner exception for details.", e);
            }

            if (result != 0)
            {
                // logger.Error("AMSI OpenSession returned an unexpected result: {result}. Aborting.", result);
                throw new AMSIException($"Failed to open an AMSI Session - the OpenSession call returned 0x{result:X}");
            }

            return session;
        }
    }
    class Tools
    {
        /// <summary>
        /// Courtesy of https://stackoverflow.com/questions/1080442/how-to-convert-an-stream-into-a-byte-in-c
        /// </summary>
        /// <param name="stream">An input stream</param>
        /// <returns>A byte array</returns>
        public static byte[] CopyToByteArray(Stream stream)
        {
            // logger.Debug($"Starting {nameof(CopyToByteArray)}");
            long originalPosition = 0;

            if (stream.CanSeek)
            {
                originalPosition = stream.Position;
                stream.Position = 0;
            }

            try
            {
                byte[] readBuffer = new byte[4096];

                int totalBytesRead = 0;
                int bytesRead;

                while ((bytesRead = stream.Read(readBuffer, totalBytesRead, readBuffer.Length - totalBytesRead)) > 0)
                {
                    totalBytesRead += bytesRead;

                    if (totalBytesRead == readBuffer.Length)
                    {
                        int nextByte = stream.ReadByte();
                        if (nextByte != -1)
                        {
                            byte[] temp = new byte[readBuffer.Length * 2];
                            Buffer.BlockCopy(readBuffer, 0, temp, 0, readBuffer.Length);
                            Buffer.SetByte(temp, totalBytesRead, (byte)nextByte);
                            readBuffer = temp;
                            totalBytesRead++;
                        }
                    }
                }

                byte[] buffer = readBuffer;
                if (readBuffer.Length != totalBytesRead)
                {
                    buffer = new byte[totalBytesRead];
                    Buffer.BlockCopy(readBuffer, 0, buffer, 0, totalBytesRead);
                }

                // logger.Debug($"{nameof(CopyToByteArray)} returning");
                return buffer;
            }
            finally
            {
                if (stream.CanSeek)
                {
                    stream.Position = originalPosition;
                }
            }
        }
    }
}
